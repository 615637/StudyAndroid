--외부키 : 키를 상속받아 사용하는 것
--규칙 : 부모가 가진 기본 키를 모두 상속받아야 함.

--게시판
--게시글 번호(key), 게시글 제목, 게시글 내용, 기타 속성(날짜, 글쓴이 등등)일 때
--게시판이 여러개 있다면 테이블이 여러개가 되어야 할까?
--CATEGORY 사용하면 된다

COMMIT;
ROLLBACK;

CREATE TABLE AND_BOARD(
    BOARD_CATEGORY VARCHAR2(10) NOT NULL,  --구분자 키
    BOARD_NO NUMBER NOT NULL,  --자동 증가(시퀀스, 트리거)
    BOARD_TITLE VARCHAR2(200),
    BOARD_CONTENT VARCHAR2(2000),
    CREATE_DATE DATE,
    CREATE_BY VARCHAR2(100),
    UPDATE_DATE DATE,
    CONSTRAINT AND_BOARD_PK PRIMARY KEY 
    (
    BOARD_CATEGORY 
  , BOARD_NO 
  )
  ENABLE,
  CONSTRAINT AND_BOARD_FK FOREIGN KEY
(
  CREATE_BY 
)
REFERENCES ANDMEMBER
(
  ID 
)
ENABLE
);

INSERT INTO AND_BOARD(BOARD_CATEGORY, BOARD_NO, BOARD_TITLE, BOARD_CONTENT, CREATE_DATE, CREATE_BY)
VALUES ('B', SEQ_AND_BOARD.NEXTVAL, '춥다', '에어컨이 쎄다', SYSDATE, 'dev');

SELECT * FROM AND_BOARD WHERE BOARD_CATEGORY = 'B';

--AND_BOARD_REPLY

CREATE TABLE AND_BOARD_REPLY(
    BOARD_CATEGORY VARCHAR2(10) NOT NULL,  --부모 테이블의 키를 참조하기 위한 컬럼1
    BOARD_NO NUMBER NOT NULL,  --부모 테이블의 키를 참조하기 위한 컬럼2
    REPLY_NO NUMBER NOT NULL,  --부모 키 컬럼 1, 2 + 댓글을 구분하기 위한 키
    REPLY_CONTENT VARCHAR2(2000),
    CREATE_DATE DATE,
    CREATE_BY VARCHAR2(100),
    UPDATE_DATE DATE,
CONSTRAINT AND_BOARD_REPLY_PK PRIMARY KEY (REPLY_NO)ENABLE,
CONSTRAINT AND_BOARD_REPLY_FK_1 FOREIGN KEY
(
  CREATE_BY 
)
REFERENCES ANDMEMBER
(
  ID 
)
ENABLE,
CONSTRAINT AND_BOARD_REPLY_FK_2 FOREIGN KEY
(
  BOARD_CATEGORY
, BOARD_NO 
)
REFERENCES AND_BOARD
(
  BOARD_CATEGORY 
, BOARD_NO 
)
ENABLE
);

SELECT * FROM AND_BOARD_REPLY;

INSERT INTO AND_BOARD_REPLY(BOARD_CATEGORY, BOARD_NO, REPLY_NO, REPLY_CONTENT, CREATE_DATE, CREATE_BY)
VALUES ('B', 1, 1,'빠이', SYSDATE, 'dev');

--시퀀스 만들기
--CREATE SEQUENCE [시퀀스 이름] INCREMENT BY [증가값(숫자)];
--CURRVAR: 현재 시퀀스(마지막 숫자), NEXTVAR: 증가값(계속 늘어남)
CREATE SEQUENCE SEQ_TEST
INCREMENT BY 1;

SELECT SEQ_TEST.NEXTVAL FROM DUAL;
DROP SEQUENCE SEQ_TEST;

--SEQ_AND_BOARD 만들어서 AND_BOARD에 INSERT
CREATE SEQUENCE SEQ_AND_BOARD
INCREMENT BY 1;

SELECT SEQ_AND_BOARD.NEXTVAL FROM DUAL;



--TRIGGER 의 기본형태.
--CREATE [ OR REPLACE ] TRIGGER [ schema.] trigger
--BEFORE | AFTER | INSTEAD OF
--DML EVENT ( INSERT [OR] UPDATE [OR] DELETE )
--ON [SCHEMA.] DATABASE TABLE
--WHEN ( 조건)
--PL/SQL_BLOCK | CALL_PROCEDURE_STATEMENT ;


--트리거 : 트랜잭션이 발생하는 작업을 하기 전 또는 후에 어떤 로직을 실행하게 만드는 것
--구분            NEW             /               OLD
--INSERT   새로들어온데이터(행)   / NULL : 데이터 행이 새로 추가될 때는 기존(OLD) 데이터는 없음
--UPDATE     바뀐 데이터(행)      /        바뀌기 전 데이터(행)
--DELETE          NULL            /        삭제되는 데이터(기존)

--FOR EACH ROW : INSERT, UPDATE, DELETE는 여러행이 한번에 작업되는 경우가 존재함. 따라서 한 행마다 작업을 구분한다.
--BEGIN END; : PL/SQL에서 { }중괄호 역할


--BEFORE <- 이벤트 -> AFTER
--TRIGGER를 이용해서 여러 시점에 대해 AND_BOARD_HISTORY에 이력 남김
CREATE TABLE AND_BOARD_HISTORY(
    BOARD_CATEGORY VARCHAR2(10) NOT NULL,
    BOARD_NO NUMBER NOT NULL,
    BOARD_TITLE VARCHAR2(200),
    BOARD_CONTENT VARCHAR2(2000),
    CREATE_DATE DATE,
    SATATUS_VALUE VARCHAR2(50));
    
CREATE OR REPLACE TRIGGER TRG_AND_BOARD
AFTER UPDATE OR DELETE -- 시점(테이블이 수정 또는 삭제 될 시)
ON AND_BOARD --트리거를 부착할 테이블 이름
FOR EACH ROW --각 행마다 적용
BEGIN --실행부 : 자바의 중괄호 (for(){})
    IF UPDATING THEN
    INSERT INTO AND_BOARD_HISTORY
    VALUES ( :OLD.BOARD_CATEGORY, :OLD.BOARD_NO, :OLD.BOARD_TITLE, :OLD.BOARD_CONTENT, sysdate, 'update');
    
    ELSIF DELETING THEN
    INSERT INTO AND_BOARD_HISTORY
    VALUES ( :OLD.BOARD_CATEGORY, :OLD.BOARD_NO, :OLD.BOARD_TITLE, :OLD.BOARD_CONTENT, sysdate, 'delete');
    
    END IF;
END;


CREATE OR REPLACE TRIGGER TRG_AND_BOARD_PK
BEFORE INSERT -- 시점(추가 전 시점)
ON AND_BOARD --트리거를 부착할 테이블 이름
FOR EACH ROW --각 행마다 적용
BEGIN --실행부 : 자바의 중괄호 (for(){})
    :NEW.BOARD_NO := SEQ_AND_BOARD.NEXTVAL;
END;


